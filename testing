local KeyGuardLibrary = loadstring(game:HttpGet("https://cdn.keyguardian.org/library/v1.0.0.lua"))()
local trueData = "5b84f5886f6645cbb39e1d054c80ea4d"
local falseData = "14c1ee2bfb5d49d1af6f0b7dd15ac441"

KeyGuardLibrary.Set({
  publicToken = "14ad943266b440adae6b8c56001aa422",
  privateToken = "4380c6dc07774161af74b793e609b050",
  trueData = trueData,
  falseData = falseData,
})

local key = "test"

local getkey = KeyGuardLibrary.getLink()
print(getkey)

local response = KeyGuardLibrary.validateDefaultKey(key)
print(response)

if response == trueData then
    local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Zyren Hub Loader", "DarkTheme")

-- Free
local Free = Window:NewTab("Free")
local FreeSection = Free:NewSection("Free Section")

FreeSection:NewButton("Arsenal", "Loads the Arsenal", function()
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Zyren Hub - Arsenal',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Silent Aim Settings')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Aimbot Settings')

-- Silent Aim Script (Toggle Version)
local silentAimEnabled = false
local players = game:GetService("Players")
local localPlayer = players.LocalPlayer

local function enableSilentAim()
    coroutine.resume(coroutine.create(function()
        while silentAimEnabled do
            for _, v in pairs(players:GetPlayers()) do
                if v.Name ~= localPlayer.Name and v.Character then
                    local parts = {
                        "RightUpperLeg",
                        "LeftUpperLeg",
                        "HeadHB",
                        "HumanoidRootPart"
                    }
                    for _, partName in ipairs(parts) do
                        local part = v.Character:FindFirstChild(partName)
                        if part then
                            part.Transparency = 10
                        end
                    end
                end
            end
            wait(1)
        end
    end))

    coroutine.resume(coroutine.create(function()
        while silentAimEnabled do
            for _, v in pairs(players:GetPlayers()) do
                if v.Name ~= localPlayer.Name and v.Character then
                    local parts = {
                        "RightUpperLeg",
                        "LeftUpperLeg",
                        "HeadHB",
                        "HumanoidRootPart"
                    }
                    for _, partName in ipairs(parts) do
                        local part = v.Character:FindFirstChild(partName)
                        if part then
                            part.CanCollide = false
                            part.Size = Vector3.new(13, 13, 13)
                        end
                    end
                end
            end
            wait(1)
        end
    end))
end

local function disableSilentAim()
    silentAimEnabled = false
end

local function toggleSilentAim(value)
    silentAimEnabled = value
    if value then
        enableSilentAim()
    else
        disableSilentAim()
    end
end

LeftGroupBox:AddToggle('SilentAim', {
    Text = 'Enable Silent Aim',
    Default = silentAimEnabled,
    Tooltip = 'Enable or disable silent aim.',
    Callback = function(Value)
        toggleSilentAim(Value)
    end
})

-- Aimbot Settings Variables
local teamCheck = true
local fov = 150
local smoothing = 1
local RunService = game:GetService('RunService')

local FOVring = Drawing.new('Circle')
FOVring.Visible = true
FOVring.Thickness = 1.5
FOVring.Radius = fov
FOVring.Transparency = 1
FOVring.Color = Color3.fromRGB(255, 255, 255)
FOVring.Position = workspace.CurrentCamera.ViewportSize / 2

local function getClosest(cframe)
    local ray = Ray.new(cframe.Position, cframe.LookVector).Unit
    local target = nil
    local mag = math.huge

    for i, v in pairs(game.Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild('Head') and v.Character:FindFirstChild('Humanoid') and v.Character:FindFirstChild('HumanoidRootPart') and v ~= game.Players.LocalPlayer and (v.Team ~= game.Players.LocalPlayer.Team or (not teamCheck)) then
            local magBuf = (v.Character.Head.Position - ray:ClosestPoint(v.Character.Head.Position)).Magnitude
            if magBuf < mag then
                mag = magBuf
                target = v
            end
        end
    end
    return target
end

local loop
loop = RunService.RenderStepped:Connect(function()
    local UserInputService = game:GetService('UserInputService')
    local pressed = UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) -- Right mouse button

    local localPlay = game.Players.LocalPlayer.Character
    local cam = workspace.CurrentCamera
    local zz = workspace.CurrentCamera.ViewportSize / 2

    if pressed then
        local Line = Drawing.new('Line')
        local curTar = getClosest(cam.CFrame)
        local ssHeadPoint = cam:WorldToScreenPoint(curTar.Character.Head.Position)
        ssHeadPoint = Vector2.new(ssHeadPoint.X, ssHeadPoint.Y)
        if (ssHeadPoint - zz).Magnitude < fov then
            workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(cam.CFrame.Position, curTar.Character.Head.Position), smoothing)
        end
    end

    if UserInputService:IsKeyDown(Enum.KeyCode.Delete) then
        loop:Disconnect()
        FOVring:Remove()
    end
end)

-- Aimbot Toggle and Settings in Right GroupBox
RightGroupBox:AddToggle('AimbotEnabled', {
    Text = 'Enable Aimbot',
    Default = false,
    Tooltip = 'Enable or disable Aimbot.',
    Callback = function(Value)
        print('[cb] Aimbot Enabled:', Value)
        -- Implement Aimbot activation logic here
    end
})


RightGroupBox:AddToggle('ShowFOVCircle', {
    Text = 'Show FOV Circle',
    Default = true,
    Tooltip = 'Enable or disable the FOV circle.',
    Callback = function(Value)
        FOVring.Visible = Value
    end
})

RightGroupBox:AddSlider('FOVRadius', {
    Text = 'FOV Radius',
    Default = 150,
    Min = 20,
    Max = 700,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        fov = Value
        FOVring.Radius = Value
    end
})

RightGroupBox:AddSlider('Sensitivity', {
    Text = 'Sensitivity',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Compact = true,
    Callback = function(Value)
        smoothing = Value
    end
})


local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Gun mods')

local replicationstorage = game.ReplicatedStorage

-- Infinite Ammo Toggle
local infiniteAmmoEnabled = false
local function toggleInfiniteAmmo(value)
    infiniteAmmoEnabled = value
    if value then
        while infiniteAmmoEnabled do
            game:GetService("Players").LocalPlayer.PlayerGui.GUI.Client.Variables.ammocount.Value = 999
            game:GetService("Players").LocalPlayer.PlayerGui.GUI.Client.Variables.ammocount2.Value = 999
            wait(0.1)
        end
    end
end

LeftGroupBox:AddToggle('InfiniteAmmo', {
    Text = 'Enable Infinite Ammo',
    Default = infiniteAmmoEnabled,
    Tooltip = 'Enable or disable infinite ammo.',
    Callback = function(Value)
        toggleInfiniteAmmo(Value)
    end
})

-- Fast Fire Toggle
local fastFireEnabled = false
local function toggleFastFire(value)
    fastFireEnabled = value
    if value then
        for i, v in pairs(replicationstorage.Weapons:GetDescendants()) do
            if v.Name == "FireRate" then
                v.Value = 0.05
            end
        end
    end
end

LeftGroupBox:AddToggle('FastFire', {
    Text = 'Enable Fast Fire',
    Default = fastFireEnabled,
    Tooltip = 'Enable or disable fast fire.',
    Callback = function(Value)
        toggleFastFire(Value)
    end
})

-- No Recoil Toggle
local noRecoilEnabled = false
local function toggleNoRecoil(value)
    noRecoilEnabled = value
    if value then
        for i, v in pairs(replicationstorage.Weapons:GetDescendants()) do
            if v.Name == "RecoilControl" then
                v.Value = 0
            end
        end
    end
end

LeftGroupBox:AddToggle('NoRecoil', {
    Text = 'Enable No Recoil',
    Default = noRecoilEnabled,
    Tooltip = 'Enable or disable no recoil.',
    Callback = function(Value)
        toggleNoRecoil(Value)
    end
})

-- Reload Speed Toggle
local reloadSpeedEnabled = false
local function toggleReloadSpeed(value)
    reloadSpeedEnabled = value
    if value then
        for i, v in pairs(replicationstorage.Weapons:GetDescendants()) do
            if v.Name == "ReloadTime" then
                v.Value = 0.00000000000000000000000001
            end
        end
    end
end

LeftGroupBox:AddToggle('ReloadSpeed', {
    Text = 'Enable Reload Speed',
    Default = reloadSpeedEnabled,
    Tooltip = 'Enable or disable reload speed.',
    Callback = function(Value)
        toggleReloadSpeed(Value)
    end
})

local ESPGroupBox = Tabs.Main:AddRightGroupbox('Esp')

local MyButton = ESPGroupBox:AddButton({
    Text = 'Skeleton ESP',
    Func = function()
        local Player = game:GetService("Players").LocalPlayer
        local Mouse = Player:GetMouse()
        local Camera = game:GetService("Workspace").CurrentCamera
        
        local function DrawLine()
            local l = Drawing.new("Line")
            l.Visible = false
            l.From = Vector2.new(0, 0)
            l.To = Vector2.new(1, 1)
            l.Color = Color3.fromRGB(255, 0, 0)
            l.Thickness = 1
            l.Transparency = 1
            return l
        end
        
        local function DrawESP(plr)
            repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil
            local limbs = {}
            local R15 = (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15) and true or false
            if R15 then 
                limbs = {
                    -- Spine
                    Head_UpperTorso = DrawLine(),
                    UpperTorso_LowerTorso = DrawLine(),
                    -- Left Arm
                    UpperTorso_LeftUpperArm = DrawLine(),
                    LeftUpperArm_LeftLowerArm = DrawLine(),
                    LeftLowerArm_LeftHand = DrawLine(),
                    -- Right Arm
                    UpperTorso_RightUpperArm = DrawLine(),
                    RightUpperArm_RightLowerArm = DrawLine(),
                    RightLowerArm_RightHand = DrawLine(),
                    -- Left Leg
                    LowerTorso_LeftUpperLeg = DrawLine(),
                    LeftUpperLeg_LeftLowerLeg = DrawLine(),
                    LeftLowerLeg_LeftFoot = DrawLine(),
                    -- Right Leg
                    LowerTorso_RightUpperLeg = DrawLine(),
                    RightUpperLeg_RightLowerLeg = DrawLine(),
                    RightLowerLeg_RightFoot = DrawLine(),
                }
            else 
                limbs = {
                    Head_Spine = DrawLine(),
                    Spine = DrawLine(),
                    LeftArm = DrawLine(),
                    LeftArm_UpperTorso = DrawLine(),
                    RightArm = DrawLine(),
                    RightArm_UpperTorso = DrawLine(),
                    LeftLeg = DrawLine(),
                    LeftLeg_LowerTorso = DrawLine(),
                    RightLeg = DrawLine(),
                    RightLeg_LowerTorso = DrawLine()
                }
            end
            local function Visibility(state)
                for i, v in pairs(limbs) do
                    v.Visible = state
                end
            end
        
            local function Colorize(color)
                for i, v in pairs(limbs) do
                    v.Color = color
                end
            end
        
            local function UpdaterR15()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                        local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        if vis then
                            -- Head
                            local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                            if limbs.Head_UpperTorso.From ~= Vector2.new(H.X, H.Y) then
                                --Spine
                                local UT = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                                local LT = Camera:WorldToViewportPoint(plr.Character.LowerTorso.Position)
                                -- Left Arm
                                local LUA = Camera:WorldToViewportPoint(plr.Character.LeftUpperArm.Position)
                                local LLA = Camera:WorldToViewportPoint(plr.Character.LeftLowerArm.Position)
                                local LH = Camera:WorldToViewportPoint(plr.Character.LeftHand.Position)
                                -- Right Arm
                                local RUA = Camera:WorldToViewportPoint(plr.Character.RightUpperArm.Position)
                                local RLA = Camera:WorldToViewportPoint(plr.Character.RightLowerArm.Position)
                                local RH = Camera:WorldToViewportPoint(plr.Character.RightHand.Position)
                                -- Left leg
                                local LUL = Camera:WorldToViewportPoint(plr.Character.LeftUpperLeg.Position)
                                local LLL = Camera:WorldToViewportPoint(plr.Character.LeftLowerLeg.Position)
                                local LF = Camera:WorldToViewportPoint(plr.Character.LeftFoot.Position)
                                -- Right leg
                                local RUL = Camera:WorldToViewportPoint(plr.Character.RightUpperLeg.Position)
                                local RLL = Camera:WorldToViewportPoint(plr.Character.RightLowerLeg.Position)
                                local RF = Camera:WorldToViewportPoint(plr.Character.RightFoot.Position)
        
                                --Head
                                limbs.Head_UpperTorso.From = Vector2.new(H.X, H.Y)
                                limbs.Head_UpperTorso.To = Vector2.new(UT.X, UT.Y)
        
                                --Spine
                                limbs.UpperTorso_LowerTorso.From = Vector2.new(UT.X, UT.Y)
                                limbs.UpperTorso_LowerTorso.To = Vector2.new(LT.X, LT.Y)
        
                                -- Left Arm
                                limbs.UpperTorso_LeftUpperArm.From = Vector2.new(UT.X, UT.Y)
                                limbs.UpperTorso_LeftUpperArm.To = Vector2.new(LUA.X, LUA.Y)
        
                                limbs.LeftUpperArm_LeftLowerArm.From = Vector2.new(LUA.X, LUA.Y)
                                limbs.LeftUpperArm_LeftLowerArm.To = Vector2.new(LLA.X, LLA.Y)
        
                                limbs.LeftLowerArm_LeftHand.From = Vector2.new(LLA.X, LLA.Y)
                                limbs.LeftLowerArm_LeftHand.To = Vector2.new(LH.X, LH.Y)
        
                                -- Right Arm
                                limbs.UpperTorso_RightUpperArm.From = Vector2.new(UT.X, UT.Y)
                                limbs.UpperTorso_RightUpperArm.To = Vector2.new(RUA.X, RUA.Y)
        
                                limbs.RightUpperArm_RightLowerArm.From = Vector2.new(RUA.X, RUA.Y)
                                limbs.RightUpperArm_RightLowerArm.To = Vector2.new(RLA.X, RLA.Y)
        
                                limbs.RightLowerArm_RightHand.From = Vector2.new(RLA.X, RLA.Y)
                                limbs.RightLowerArm_RightHand.To = Vector2.new(RH.X, RH.Y)
        
                                -- Left Leg
                                limbs.LowerTorso_LeftUpperLeg.From = Vector2.new(LT.X, LT.Y)
                                limbs.LowerTorso_LeftUpperLeg.To = Vector2.new(LUL.X, LUL.Y)
        
                                limbs.LeftUpperLeg_LeftLowerLeg.From = Vector2.new(LUL.X, LUL.Y)
                                limbs.LeftUpperLeg_LeftLowerLeg.To = Vector2.new(LLL.X, LLL.Y)
        
                                limbs.LeftLowerLeg_LeftFoot.From = Vector2.new(LLL.X, LLL.Y)
                                limbs.LeftLowerLeg_LeftFoot.To = Vector2.new(LF.X, LF.Y)
        
                                -- Right Leg
                                limbs.LowerTorso_RightUpperLeg.From = Vector2.new(LT.X, LT.Y)
                                limbs.LowerTorso_RightUpperLeg.To = Vector2.new(RUL.X, RUL.Y)
        
                                limbs.RightUpperLeg_RightLowerLeg.From = Vector2.new(RUL.X, RUL.Y)
                                limbs.RightUpperLeg_RightLowerLeg.To = Vector2.new(RLL.X, RLL.Y)
        
                                limbs.RightLowerLeg_RightFoot.From = Vector2.new(RLL.X, RLL.Y)
                                limbs.RightLowerLeg_RightFoot.To = Vector2.new(RF.X, RF.Y)
                            end
        
                            if limbs.Head_UpperTorso.Visible ~= true then
                                Visibility(true)
                            end
                        else 
                            if limbs.Head_UpperTorso.Visible ~= false then
                                Visibility(false)
                            end
                        end
                    else 
                        if limbs.Head_UpperTorso.Visible ~= false then
                            Visibility(false)
                        end
                        if game.Players:FindFirstChild(plr.Name) == nil then 
                            for i, v in pairs(limbs) do
                                v:Remove()
                            end
                            connection:Disconnect()
                        end
                    end
                end)
            end
        
            local function UpdaterR6()
                local connection
                connection = game:GetService("RunService").RenderStepped:Connect(function()
                    if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                        local HUM, vis = Camera:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
                        if vis then
                            local H = Camera:WorldToViewportPoint(plr.Character.Head.Position)
                            if limbs.Head_Spine.From ~= Vector2.new(H.X, H.Y) then
                                local T_Height = plr.Character.Torso.Size.Y/2 - 0.2
                                local UT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, T_Height, 0)).p)
                                local LT = Camera:WorldToViewportPoint((plr.Character.Torso.CFrame * CFrame.new(0, -T_Height, 0)).p)
        
                                local LA_Height = plr.Character["Left Arm"].Size.Y/2 - 0.2
                                local LUA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, LA_Height, 0)).p)
                                local LLA = Camera:WorldToViewportPoint((plr.Character["Left Arm"].CFrame * CFrame.new(0, -LA_Height, 0)).p)
        
                                local RA_Height = plr.Character["Right Arm"].Size.Y/2 - 0.2
                                local RUA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, RA_Height, 0)).p)
                                local RLA = Camera:WorldToViewportPoint((plr.Character["Right Arm"].CFrame * CFrame.new(0, -RA_Height, 0)).p)
        
                                local LL_Height = plr.Character["Left Leg"].Size.Y/2 - 0.2
                                local LUL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, LL_Height, 0)).p)
                                local LLL = Camera:WorldToViewportPoint((plr.Character["Left Leg"].CFrame * CFrame.new(0, -LL_Height, 0)).p)
        
                                local RL_Height = plr.Character["Right Leg"].Size.Y/2 - 0.2
                                local RUL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, RL_Height, 0)).p)
                                local RLL = Camera:WorldToViewportPoint((plr.Character["Right Leg"].CFrame * CFrame.new(0, -RL_Height, 0)).p)
        
                                -- Head
                                limbs.Head_Spine.From = Vector2.new(H.X, H.Y)
                                limbs.Head_Spine.To = Vector2.new(UT.X, UT.Y)
        
                                --Spine
                                limbs.Spine.From = Vector2.new(UT.X, UT.Y)
                                limbs.Spine.To = Vector2.new(LT.X, LT.Y)
        
                                --Left Arm
                                limbs.LeftArm.From = Vector2.new(LUA.X, LUA.Y)
                                limbs.LeftArm.To = Vector2.new(LLA.X, LLA.Y)
        
                                limbs.LeftArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                                limbs.LeftArm_UpperTorso.To = Vector2.new(LUA.X, LUA.Y)
        
                                --Right Arm
                                limbs.RightArm.From = Vector2.new(RUA.X, RUA.Y)
                                limbs.RightArm.To = Vector2.new(RLA.X, RLA.Y)
        
                                limbs.RightArm_UpperTorso.From = Vector2.new(UT.X, UT.Y)
                                limbs.RightArm_UpperTorso.To = Vector2.new(RUA.X, RUA.Y)
        
                                --Left Leg
                                limbs.LeftLeg.From = Vector2.new(LUL.X, LUL.Y)
                                limbs.LeftLeg.To = Vector2.new(LLL.X, LLL.Y)
        
                                limbs.LeftLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                                limbs.LeftLeg_LowerTorso.To = Vector2.new(LUL.X, LUL.Y)
        
                                --Right Leg
                                limbs.RightLeg.From = Vector2.new(RUL.X, RUL.Y)
                                limbs.RightLeg.To = Vector2.new(RLL.X, RLL.Y)
        
                                limbs.RightLeg_LowerTorso.From = Vector2.new(LT.X, LT.Y)
                                limbs.RightLeg_LowerTorso.To = Vector2.new(RUL.X, RUL.Y)
                            end
        
                            if limbs.Head_Spine.Visible ~= true then
                                Visibility(true)
                            end
                        else 
                            if limbs.Head_Spine.Visible ~= false then
                                Visibility(false)
                            end
                        end
                    else 
                        if limbs.Head_Spine.Visible ~= false then
                            Visibility(false)
                        end
                        if game.Players:FindFirstChild(plr.Name) == nil then 
                            for i, v in pairs(limbs) do
                                v:Remove()
                            end
                            connection:Disconnect()
                        end
                    end
                end)
            end
        
            if R15 then
                coroutine.wrap(UpdaterR15)()
            else 
                coroutine.wrap(UpdaterR6)()
            end
        end
        
        for i, v in pairs(game:GetService("Players"):GetPlayers()) do
            if v.Name ~= Player.Name then
                DrawESP(v)
            end
        end
        
        game.Players.PlayerAdded:Connect(function(newplr)
            if newplr.Name ~= Player.Name then
                DrawESP(newplr)
            end
        end)
        end,
    DoubleClick = false,
    Tooltip = 'Skeleton ESP'
})

local MyButton = ESPGroupBox:AddButton({
    Text = 'Arrows',
    Func = function()
-- Made by Blissful#4992

local DistFromCenter = 80
local TriangleHeight = 16
local TriangleWidth = 16
local TriangleFilled = true
local TriangleTransparency = 0
local TriangleThickness = 1
local TriangleColor = Color3.fromRGB(255, 255, 255)
local AntiAliasing = false

----------------------------------------------------------------

local Players = game:service("Players")
local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RS = game:service("RunService")

local V3 = Vector3.new
local V2 = Vector2.new
local CF = CFrame.new
local COS = math.cos
local SIN = math.sin
local RAD = math.rad
local DRAWING = Drawing.new
local CWRAP = coroutine.wrap
local ROUND = math.round

local function GetRelative(pos, char)
    if not char then return V2(0,0) end

    local rootP = char.PrimaryPart.Position
    local camP = Camera.CFrame.Position
    local relative = CF(V3(rootP.X, camP.Y, rootP.Z), camP):PointToObjectSpace(pos)

    return V2(relative.X, relative.Z)
end

local function RelativeToCenter(v)
    return Camera.ViewportSize/2 - v
end

local function RotateVect(v, a)
    a = RAD(a)
    local x = v.x * COS(a) - v.y * SIN(a)
    local y = v.x * SIN(a) + v.y * COS(a)

    return V2(x, y)
end

local function DrawTriangle(color)
    local l = DRAWING("Triangle")
    l.Visible = false
    l.Color = color
    l.Filled = TriangleFilled
    l.Thickness = TriangleThickness
    l.Transparency = 1-TriangleTransparency
    return l
end

local function AntiA(v)
    if (not AntiAliasing) then return v end
    return V2(ROUND(v.x), ROUND(v.y))
end

local function ShowArrow(PLAYER)
    local Arrow = DrawTriangle(TriangleColor)

    local function Update()
        local c ; c = RS.RenderStepped:Connect(function()
            if PLAYER and PLAYER.Character then
                local CHAR = PLAYER.Character
                local HUM = CHAR:FindFirstChildOfClass("Humanoid")

                if HUM and CHAR.PrimaryPart ~= nil and HUM.Health > 0 then
                    local _,vis = Camera:WorldToViewportPoint(CHAR.PrimaryPart.Position)
                    if vis == false then
                        local rel = GetRelative(CHAR.PrimaryPart.Position, Player.Character)
                        local direction = rel.unit

                        local base  = direction * DistFromCenter
                        local sideLength = TriangleWidth/2
                        local baseL = base + RotateVect(direction, 90) * sideLength
                        local baseR = base + RotateVect(direction, -90) * sideLength

                        local tip = direction * (DistFromCenter + TriangleHeight)
                        
                        Arrow.PointA = AntiA(RelativeToCenter(baseL))
                        Arrow.PointB = AntiA(RelativeToCenter(baseR))

                        Arrow.PointC = AntiA(RelativeToCenter(tip))

                        Arrow.Visible = true

                    else Arrow.Visible = false end
                else Arrow.Visible = false end
            else 
                Arrow.Visible = false

                if not PLAYER or not PLAYER.Parent then
                    Arrow:Remove()
                    c:Disconnect()
                end
            end
        end)
    end

    CWRAP(Update)()
end

for _,v in pairs(Players:GetChildren()) do
    if v.Name ~= Player.Name then
        ShowArrow(v)
    end
end

Players.PlayerAdded:Connect(function(v)
    if v.Name ~= Player.Name then
        ShowArrow(v)
    end
end)
    end,
    DoubleClick = false,
    Tooltip = 'Arrow ESP'
})

local MyButton = ESPGroupBox:AddButton({
    Text = 'ESP Radar',
    Func = function()
-- Made by Blissful#4992
local Players = game:service("Players")
local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()
local Camera = game:service("Workspace").CurrentCamera
local RS = game:service("RunService")
local UIS = game:service("UserInputService")

repeat wait() until Player.Character ~= nil and Player.Character.PrimaryPart ~= nil

local LerpColorModule = loadstring(game:HttpGet("https://pastebin.com/raw/wRnsJeid"))()
local HealthBarLerp = LerpColorModule:Lerp(Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0))

local function NewCircle(Transparency, Color, Radius, Filled, Thickness)
    local c = Drawing.new("Circle")
    c.Transparency = Transparency
    c.Color = Color
    c.Visible = false
    c.Thickness = Thickness
    c.Position = Vector2.new(0, 0)
    c.Radius = Radius
    c.NumSides = math.clamp(Radius*55/100, 10, 75)
    c.Filled = Filled
    return c
end

local RadarInfo = {
    Position = Vector2.new(200, 200),
    Radius = 100,
    Scale = 1, -- Determinant factor on the effect of the relative position for the 2D integration
    RadarBack = Color3.fromRGB(10, 10, 10),
    RadarBorder = Color3.fromRGB(75, 75, 75),
    LocalPlayerDot = Color3.fromRGB(255, 255, 255),
    PlayerDot = Color3.fromRGB(60, 170, 255),
    Team = Color3.fromRGB(0, 255, 0),
    Enemy = Color3.fromRGB(255, 0, 0),
    Health_Color = true,
    Team_Check = true
}

local RadarBackground = NewCircle(0.9, RadarInfo.RadarBack, RadarInfo.Radius, true, 1)
RadarBackground.Visible = true
RadarBackground.Position = RadarInfo.Position

local RadarBorder = NewCircle(0.75, RadarInfo.RadarBorder, RadarInfo.Radius, false, 3)
RadarBorder.Visible = true
RadarBorder.Position = RadarInfo.Position

local function GetRelative(pos)
    local char = Player.Character
    if char ~= nil and char.PrimaryPart ~= nil then
        local pmpart = char.PrimaryPart
        local camerapos = Vector3.new(Camera.CFrame.Position.X, pmpart.Position.Y, Camera.CFrame.Position.Z)
        local newcf = CFrame.new(pmpart.Position, camerapos)
        local r = newcf:PointToObjectSpace(pos)
        return r.X, r.Z
    else
        return 0, 0
    end
end

local function PlaceDot(plr)
    local PlayerDot = NewCircle(1, RadarInfo.PlayerDot, 3, true, 1)

    local function Update()
        local c 
        c = game:service("RunService").RenderStepped:Connect(function()
            local char = plr.Character
            if char and char:FindFirstChildOfClass("Humanoid") and char.PrimaryPart ~= nil and char:FindFirstChildOfClass("Humanoid").Health > 0 then
                local hum = char:FindFirstChildOfClass("Humanoid")
                local scale = RadarInfo.Scale
                local relx, rely = GetRelative(char.PrimaryPart.Position)
                local newpos = RadarInfo.Position - Vector2.new(relx * scale, rely * scale) 
                
                if (newpos - RadarInfo.Position).magnitude < RadarInfo.Radius-2 then 
                    PlayerDot.Radius = 3   
                    PlayerDot.Position = newpos
                    PlayerDot.Visible = true
                else 
                    local dist = (RadarInfo.Position - newpos).magnitude
                    local calc = (RadarInfo.Position - newpos).unit * (dist - RadarInfo.Radius)
                    local inside = Vector2.new(newpos.X + calc.X, newpos.Y + calc.Y)
                    PlayerDot.Radius = 2
                    PlayerDot.Position = inside
                    PlayerDot.Visible = true
                end

                PlayerDot.Color = RadarInfo.PlayerDot
                if RadarInfo.Team_Check then
                    if plr.TeamColor == Player.TeamColor then
                        PlayerDot.Color = RadarInfo.Team
                    else
                        PlayerDot.Color = RadarInfo.Enemy
                    end
                end

                if RadarInfo.Health_Color then
                    PlayerDot.Color = HealthBarLerp(hum.Health / hum.MaxHealth)
                end
            else 
                PlayerDot.Visible = false
                if Players:FindFirstChild(plr.Name) == nil then
                    PlayerDot:Remove()
                    c:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Update)()
end

for _,v in pairs(Players:GetChildren()) do
    if v.Name ~= Player.Name then
        PlaceDot(v)
    end
end

local function NewLocalDot()
    local d = Drawing.new("Triangle")
    d.Visible = true
    d.Thickness = 1
    d.Filled = true
    d.Color = RadarInfo.LocalPlayerDot
    d.PointA = RadarInfo.Position + Vector2.new(0, -6)
    d.PointB = RadarInfo.Position + Vector2.new(-3, 6)
    d.PointC = RadarInfo.Position + Vector2.new(3, 6)
    return d
end

local LocalPlayerDot = NewLocalDot()

Players.PlayerAdded:Connect(function(v)
    if v.Name ~= Player.Name then
        PlaceDot(v)
    end
    LocalPlayerDot:Remove()
    LocalPlayerDot = NewLocalDot()
end)

-- Loop
coroutine.wrap(function()
    local c 
    c = game:service("RunService").RenderStepped:Connect(function()
        if LocalPlayerDot ~= nil then
            LocalPlayerDot.Color = RadarInfo.LocalPlayerDot
            LocalPlayerDot.PointA = RadarInfo.Position + Vector2.new(0, -6)
            LocalPlayerDot.PointB = RadarInfo.Position + Vector2.new(-3, 6)
            LocalPlayerDot.PointC = RadarInfo.Position + Vector2.new(3, 6)
        end
        RadarBackground.Position = RadarInfo.Position
        RadarBackground.Radius = RadarInfo.Radius
        RadarBackground.Color = RadarInfo.RadarBack

        RadarBorder.Position = RadarInfo.Position
        RadarBorder.Radius = RadarInfo.Radius
        RadarBorder.Color = RadarInfo.RadarBorder
    end)
end)()

-- Draggable
local inset = game:service("GuiService"):GetGuiInset()

local dragging = false
local offset = Vector2.new(0, 0)
UIS.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 and (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
        offset = RadarInfo.Position - Vector2.new(Mouse.X, Mouse.Y)
        dragging = true
    end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)

coroutine.wrap(function()
    local dot = NewCircle(1, Color3.fromRGB(255, 255, 255), 3, true, 1)
    local c 
    c = game:service("RunService").RenderStepped:Connect(function()
        if (Vector2.new(Mouse.X, Mouse.Y + inset.Y) - RadarInfo.Position).magnitude < RadarInfo.Radius then
            dot.Position = Vector2.new(Mouse.X, Mouse.Y + inset.Y)
            dot.Visible = true
        else 
            dot.Visible = false
        end
        if dragging then
            RadarInfo.Position = Vector2.new(Mouse.X, Mouse.Y) + offset
        end
    end)
end)()
    end,
    DoubleClick = false,
    Tooltip = 'Radar lol'
})

-- UI Settings & Keybinds
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu keybind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- ThemeManager (Allows you to have a menu theme system)

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we don't want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- Adds our MenuKeybind to the ignore list
-- (do you want each config to have a different menu key? probably not.)
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])

-- Builds our theme menu (with plenty of built-in themes) on the left side
-- NOTE: you can also call ThemeManager:ApplyToGroupbox to add it to a specific groupbox
ThemeManager:ApplyToTab(Tabs['UI Settings'])

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
end)

FreeSection:NewButton("Build A Boat", "Loads the Build a Boat for treasure version of Zyren Hub", function()
    local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
    Name = "Zyren Hub - Build A Boat",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Build a boat Edition",
    LoadingSubtitle = "Zyren Hub",
    Theme = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

-- Auto Farm
local Auto = Window:CreateTab("Auto Farm", 4483362458) -- Title, Image
local AutoSection = Auto:CreateSection("Auto Farm Section")

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
    if not autofarm then return end
    autofarmstart()
end)

-- Custom Settings
getgenv().TreasureAutoFarm = {
    Enabled = false, -- Default state of auto farm is off
    Teleport = 3.40, -- Time between each teleport (this value will be controlled by the slider)
    TimeBetweenRuns = 6 -- Time between runs
}

-- Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")

-- Vars
local LocalPlayer = Players.LocalPlayer
local autoFarmRun = 1

-- Goes through all of the stages
local autoFarm = function(currentRun)
    -- Variables
    local Character = LocalPlayer.Character
    local NormalStages = Workspace.BoatStages.NormalStages

    -- Go to each stage
    for i = 1, 10 do
        local Stage = NormalStages["CaveStage" .. i]
        local DarknessPart = Stage:FindFirstChild("DarknessPart")

        if DarknessPart then
            -- Teleport to next stage
            print("Teleporting to next stage: Stage " .. i)
            Character.HumanoidRootPart.CFrame = DarknessPart.CFrame

            -- Create a temp part under you
            local Part = Instance.new("Part", LocalPlayer.Character)
            Part.Anchored = true
            Part.Position = LocalPlayer.Character.HumanoidRootPart.Position - Vector3.new(0, 6, 0)

            -- Wait and remove temp part
            wait(getgenv().TreasureAutoFarm.Teleport)
            Part:Destroy()
        end
    end

    -- Go to end
    print("Teleporting to the end")
    repeat wait()
        Character.HumanoidRootPart.CFrame = NormalStages.TheEnd.GoldenChest.Trigger.CFrame
    until Lighting.ClockTime ~= 35

    -- Wait until you have respawned
    local Respawned = false
    local Connection
    Connection = LocalPlayer.CharacterAdded:Connect(function()
        Respawned = true
        Connection:Disconnect()
    end)

    repeat wait() until Respawned
    wait(getgenv().TreasureAutoFarm.TimeBetweenRuns)
    print("Auto Farm: Run " .. currentRun .. " finished")
end

-- Create Toggle for TP Farm
local Toggle = Auto:CreateToggle({
   Name = "TP Farm", 
   CurrentValue = false, -- Default value is false (off)
   Flag = "Toggle1", -- A flag is the identifier for the configuration file
   Callback = function(Value)
      getgenv().TreasureAutoFarm.Enabled = Value -- Set Enabled to the toggle value (true or false)
      if getgenv().TreasureAutoFarm.Enabled then
         print("Auto Farm Enabled")
         while getgenv().TreasureAutoFarm.Enabled do
            print("Starting Auto Farm: Run " .. autoFarmRun)
            autoFarm(autoFarmRun) -- Run autoFarm function
            autoFarmRun = autoFarmRun + 1
            wait() -- Wait before the next run
         end
      else
         print("Auto Farm Disabled")
      end
   end,
})

-- Create Slider for TP Farm Speed (Controls teleport speed)
local Slider = Auto:CreateSlider({ 
   Name = "TP Farm Speed", 
   Range = {0, 10},         -- Adjust the range to a smaller scale (e.g., 0 to 10 seconds between teleports)
   Increment = 0.10,        -- Smaller increments for fine-tuned adjustments
   Suffix = "Seconds",      -- Suffix to indicate the unit of time (seconds)
   CurrentValue = 3.40,     -- Default value (set this to a reasonable starting time, like 3.4 seconds)
   Flag = "Slider1",        -- A flag to keep the configuration unique
   Callback = function(Value)
      getgenv().TreasureAutoFarm.Teleport = Value  -- Update teleport speed when slider changes
   end,
})


local Team = Window:CreateTab("Team TP", 4483362458) -- Title, Image
local SectionSection = Team:CreateSection("Team TP")

local Button = Team:CreateButton({
    Name = "White Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-49, -10, -491)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Black Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-477, -10, -70)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Red Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(370, -10, -64)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Green Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-478, -10, 294)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Blue Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(370, -10, 300)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Yellow Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-478, -10, 641)
    end,
 })

 local Button = Team:CreateButton({
    Name = "Purple Team",
    Callback = function()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(370, -10, 646)  -- Adjust this position as needed
    end,
 })


-- Esp
local Esp = Window:CreateTab("Esp", 4483362458) -- Title, Image
local EspSection = Esp:CreateSection("Esp Section")


local player = game.Players.LocalPlayer
local highlightColor = Color3.fromRGB(255, 255, 255) -- Outline color for the highlight
local highlightEnabled = false -- Track whether highlights are enabled

-- Function to add highlight to a character
local function addHighlightToCharacter(character)
   if character:FindFirstChild("Highlight") then return end -- Prevent duplicate highlights
   local highlight = Instance.new("Highlight", character)
   highlight.Name = "Highlight"
   highlight.OutlineColor = highlightColor
   highlight.FillTransparency = 1
end

-- Function to remove highlight from a character
local function removeHighlightFromCharacter(character)
   if character:FindFirstChild("Highlight") then
       character.Highlight:Destroy()
   end
end

-- Function to toggle highlights on/off
local function toggleHighlights()
   if highlightEnabled then
       -- Add highlight to all current players
       for _, plr in pairs(game.Players:GetPlayers()) do
           if plr.Character then
               addHighlightToCharacter(plr.Character)
           end
           plr.CharacterAdded:Connect(function(char)
               addHighlightToCharacter(char)
           end)
       end
   else
       -- Remove highlight from all players
       for _, plr in pairs(game.Players:GetPlayers()) do
           if plr.Character then
               removeHighlightFromCharacter(plr.Character)
           end
           plr.CharacterAdded:Connect(function(char)
               removeHighlightFromCharacter(char)
           end)
       end
   end
end

local Toggle = Esp:CreateToggle({
   Name = "Toggle Highlights",
   CurrentValue = false,
   Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
       highlightEnabled = Value
       toggleHighlights()
   end,
})


-- Ensure highlight is applied to the local player's character if the toggle is on
if highlightEnabled and player.Character then
   addHighlightToCharacter(player.Character)
end

-- Misc
local Misc = Window:CreateTab("Misc", 4483362458) -- Title, Image
local MiscSection = Misc:CreateSection("Misc Section")

local Noclip = nil
local Clip = true

function noclip()
    Clip = false
    local function Nocl()
        if Clip == false and game.Players.LocalPlayer.Character ~= nil then
            for _,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
                    v.CanCollide = false
                end
            end
        end
        wait(0.21)
    end
    Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

function clip()
    if Noclip then
        Noclip:Disconnect()
    end
    Clip = true
    -- Reset collision for all parts in the character
    if game.Players.LocalPlayer.Character then
        for _,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if v:IsA('BasePart') then
                v.CanCollide = true
            end
        end
    end
end

local Toggle = Misc:CreateToggle({
    Name = "No Clip",
    CurrentValue = false,
    Flag = "Toggle1", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value then
            noclip()
        else
            clip()
        end
    end,
 })

 local Button = Misc:CreateButton({
    Name = "RTX Graphics",
    Callback = function()
              		-- local Vignette = false


local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local Bloom = Instance.new("BloomEffect")
local Blur = Instance.new("BlurEffect")
local ColorCor = Instance.new("ColorCorrectionEffect")
local SunRays = Instance.new("SunRaysEffect")
local Sky = Instance.new("Sky")
local Atm = Instance.new("Atmosphere")


for i, v in pairs(Lighting:GetChildren()) do
    if v then
        v:Destroy()
    end
end

Bloom.Parent = Lighting
Blur.Parent = Lighting
ColorCor.Parent = Lighting
SunRays.Parent = Lighting
Sky.Parent = Lighting
Atm.Parent = Lighting

if Vignette == true then
    local Gui = Instance.new("ScreenGui")
    Gui.Parent = StarterGui
    Gui.IgnoreGuiInset = true
    
    local ShadowFrame = Instance.new("ImageLabel")
    ShadowFrame.Parent = Gui
    ShadowFrame.AnchorPoint = Vector2.new(0.5,1)
    ShadowFrame.Position = UDim2.new(0.5,0,1,0)
    ShadowFrame.Size = UDim2.new(1,0,1.05,0)
    ShadowFrame.BackgroundTransparency = 1
    ShadowFrame.Image = "rbxassetid://4576475446"
    ShadowFrame.ImageTransparency = 0.3
    ShadowFrame.ZIndex = 10
end

Bloom.Intensity = 0.3
Bloom.Size = 10
Bloom.Threshold = 0.8

Blur.Size = 5
ColorCor.Brightness = 0.1
ColorCor.Contrast = 0.5
ColorCor.Saturation = -0.3
ColorCor.TintColor = Color3.fromRGB(255, 235, 203)

SunRays.Intensity = 0.075
SunRays.Spread = 0.727

Sky.SkyboxBk = "http://www.roblox.com/asset/?id=151165214"
Sky.SkyboxDn = "http://www.roblox.com/asset/?id=151165197"
Sky.SkyboxFt = "http://www.roblox.com/asset/?id=151165224"
Sky.SkyboxLf = "http://www.roblox.com/asset/?id=151165191"
Sky.SkyboxRt = "http://www.roblox.com/asset/?id=151165206"
Sky.SkyboxUp = "http://www.roblox.com/asset/?id=151165227"
Sky.SunAngularSize = 10


Lighting.Ambient = Color3.fromRGB(2,2,2)
Lighting.Brightness = 2.25
Lighting.ColorShift_Bottom = Color3.fromRGB(0,0,0)
Lighting.ColorShift_Top = Color3.fromRGB(0,0,0)
Lighting.EnvironmentDiffuseScale = 0.2
Lighting.EnvironmentSpecularScale = 0.2
Lighting.GlobalShadows = true
Lighting.OutdoorAmbient = Color3.fromRGB(0,0,0)
Lighting.ShadowSoftness = 0.2
Lighting.ClockTime = 17
Lighting.GeographicLatitude = 45
Lighting.ExposureCompensation = 0.5

Atm.Density = 0.364
Atm.Offset = 0.556
Atm.Color = Color3.fromRGB(199, 175, 166)
Atm.Decay = Color3.fromRGB(44, 39, 33)
Atm.Glare = 0.36
Atm.Haze = 1.72

script:Destroy()
    end,
 })

local Button = Misc:CreateButton({
    Name = "Rejoin",
    Callback = function()
        game:GetService("TeleportService"):Teleport(game.PlaceId, game.Players.LocalPlayer)
    end,
 })
end)

FreeSection:NewButton("Universal", "Loads the Universal Version of Zyren Hub!", function()
    local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({

    Title = 'Zyren Hub - Universal',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('PVP')
}

local Area = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local MyCharacter = LocalPlayer.Character
local MyHead = MyCharacter:FindFirstChild("Head")
local MyHumanoid = MyCharacter:FindFirstChild("Humanoid")
local Mouse = LocalPlayer:GetMouse()
local MyView = Area.CurrentCamera
local MyTeamColor = LocalPlayer.TeamColor
local HoldingM2 = false
local Active = false
local Lock = false
local Epitaph = 0.05  -- Very low prediction (change this value to make the prediction very low)
local HeadOffset = Vector3.new(0, 0.1, 0) -- Small offset to target head more effectively

-- Default Settings
_G.TeamCheck = false
_G.AimPart = "Head" -- Set the part to "Head" for aiming
_G.Sensitivity = 0
_G.CircleSides = 64
_G.CircleColor = Color3.fromRGB(255, 0, 130)
_G.CircleTransparency = 0.5  -- Set a bit of transparency for visibility
_G.CircleRadius = 150
_G.CircleFilled = false
_G.CircleVisible = true
_G.CircleThickness = 2  -- Make the circle thicker
_G.RainbowSpeed = 1  -- Speed for rainbow effect (default)
_G.RainbowFOVEnabled = false  -- Toggle for rainbow FOV effect

-- Create the FOV circle using the Drawing library
local FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(MyView.ViewportSize.X / 2, MyView.ViewportSize.Y / 2)
FOVCircle.Radius = _G.CircleRadius
FOVCircle.Filled = _G.CircleFilled  -- Set FOV fill based on setting
FOVCircle.Color = _G.CircleColor
FOVCircle.Visible = _G.CircleVisible  -- Set visibility based on setting
FOVCircle.Transparency = _G.CircleTransparency
FOVCircle.NumSides = _G.CircleSides
FOVCircle.Thickness = _G.CircleThickness

-- Update the circle's position continuously to stay in the center of the screen
RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(MyView.ViewportSize.X / 2, MyView.ViewportSize.Y / 2)  -- Keep the circle centered

    -- Rainbow effect for FOV circle if enabled
    if _G.RainbowFOVEnabled and _G.RainbowSpeed > 0 then
        local time = tick() * _G.RainbowSpeed
        local color = Color3.fromHSV(math.sin(time) * 0.5 + 0.5, 1, 1)  -- Rainbow effect
        FOVCircle.Color = color
    else
        FOVCircle.Color = _G.CircleColor  -- Use static color if Rainbow FOV is not enabled
    end
end)

local PVPGroupBox = Tabs.Main:AddLeftGroupbox('Aimlock')

PVPGroupBox:AddToggle('MyToggle', {
    Text = 'Aimlock',
    Default = false,
    Tooltip = 'Enable or Disable Aimlock',
    Callback = function(Value)
        _G.AimlockEnabled = Value
    end
})

-- Show FOV Toggle
PVPGroupBox:AddToggle('ShowFOVToggle', {
    Text = 'Show FOV Circle',
    Default = true,
    Tooltip = 'Show or Hide the FOV Circle',
    Callback = function(Value)
        _G.CircleVisible = Value
        FOVCircle.Visible = Value
    end
})

-- Fill FOV Toggle
PVPGroupBox:AddToggle('FillFOVToggle', {
    Text = 'Fill FOV Circle',
    Default = false,
    Tooltip = 'Enable or Disable filling the FOV circle',
    Callback = function(Value)
        _G.CircleFilled = Value
        FOVCircle.Filled = Value
    end
})

-- Team Check Toggle
PVPGroupBox:AddToggle('TeamCheckToggle', {
    Text = 'Team Check',
    Default = false,
    Tooltip = 'Enable or Disable Team Check for Aimlock',
    Callback = function(Value)
        _G.TeamCheck = Value
    end
})

-- FOV Size Slider (from 60 to 650)
PVPGroupBox:AddSlider('FOVSlider', {
    Text = 'FOV Size',
    Default = 150,
    Min = 60,
    Max = 650,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        _G.CircleRadius = Value
        FOVCircle.Radius = Value
    end
})

-- Rainbow Speed Slider (speed for rainbow effect)
PVPGroupBox:AddSlider('RainbowSpeedSlider', {
    Text = 'Rainbow Speed',
    Default = 1,
    Min = 0,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.RainbowSpeed = Value
    end
})

-- FOV Color Picker
PVPGroupBox:AddLabel('Color'):AddColorPicker('ColorPicker', { 
    Default = Color3.new(255, 255, 255),
    Title = 'FOV Color',
    Transparency = 0, 

    Callback = function(Value)
        _G.CircleColor = Value
        FOVCircle.Color = Value
    end
})



-- Rainbow FOV Toggle
PVPGroupBox:AddToggle('RainbowFOVToggle', {
    Text = 'Rainbow FOV Effect',
    Default = false,
    Tooltip = 'Enable or Disable Rainbow Effect for the FOV Circle',
    Callback = function(Value)
        _G.RainbowFOVEnabled = Value
    end
})

-- Aimbot Logic
local function CursorLock()
    UIS.MouseBehavior = Enum.MouseBehavior.LockCenter
end

local function UnLockCursor()
    HoldingM2 = false
    Active = false
    Lock = false
    UIS.MouseBehavior = Enum.MouseBehavior.Default
end

-- Function to find the nearest player and return the head part
function FindNearestPlayer()
    local dist = math.huge
    local Target = nil
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("Head") then
            -- Skip team check if TeamCheck is disabled
            if _G.TeamCheck and v.Team == LocalPlayer.Team then
                continue
            end

            local TheirCharacter = v.Character
            local CharacterHead = TheirCharacter:FindFirstChild("Head")
            if CharacterHead then
                local CharacterRoot, Visible = MyView:WorldToViewportPoint(CharacterHead.Position)
                if Visible then
                    local RealMag = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(CharacterRoot.X, CharacterRoot.Y)).Magnitude
                    if RealMag < dist and RealMag < FOVCircle.Radius then
                        dist = RealMag
                        Target = TheirCharacter
                    end
                end
            end
        end
    end
    return Target
end

-- Input events for holding and releasing the mouse button (Aimlock)
UIS.InputBegan:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 and _G.AimlockEnabled then
        HoldingM2 = true
        Active = true
        Lock = true
        if Active then
            local The_Enemy = FindNearestPlayer()
            while HoldingM2 do
                task.wait(0.000001) -- Small wait to avoid performance issues
                if Lock and The_Enemy then
                    local TargetHead = The_Enemy:FindFirstChild("Head")
                    if TargetHead then
                        -- Predict the future position based on velocity (with low prediction)
                        local FuturePosition = TargetHead.Position + (The_Enemy.HumanoidRootPart.Velocity * Epitaph + HeadOffset)
                        MyView.CFrame = CFrame.lookAt(MyView.CFrame.Position, FuturePosition)
                        CursorLock()
                    end
                end
            end
        end
    end
end)

UIS.InputEnded:Connect(function(Input)
    if Input.UserInputType == Enum.UserInputType.MouseButton2 then
        UnLockCursor()
    end
end)

_G.EnableESP = false
_G.TeamCheck = false
_G.SquareFilled = false
_G.SquareTransparency = 0.7
_G.SquareColor = Color3.fromRGB(255, 80, 10)
_G.SquareThickness = 1
_G.RainbowESP = false
_G.RainbowSpeed = 0.5
_G.SquaresVisible = true
_G.HeadOffset = Vector3.new(0, 0.5, 0)
_G.LegsOffset = Vector3.new(0, 3, 0)

-- Box Groupbox for ESP settings
local BoxGroupBox = Tabs.Main:AddRightGroupbox('2D Squares')

-- Toggle for enabling ESP
BoxGroupBox:AddToggle('EnableESP', { 
    Text = 'Enable ESP', 
    Default = _G.EnableESP,
    Tooltip = 'Toggle to enable/disable ESP for players',
    Callback = function(Value)
        _G.EnableESP = Value  -- Store the state of the ESP toggle
    end
})

-- Toggle for Team Check
BoxGroupBox:AddToggle('TeamCheck', { 
    Text = 'Team Check', 
    Default = _G.TeamCheck,
    Tooltip = 'Only show ESP for enemy team players',
    Callback = function(Value)
        _G.TeamCheck = Value  -- Store the state of the Team Check toggle
    end
})

BoxGroupBox:AddLabel('Color'):AddColorPicker('ColorPicker', { 
    Default = Color3.fromRGB(255, 255, 255),  -- Default color for 2D boxes
    Title = '2D Boxes Color',
    Transparency = 0,  -- Transparency level (0 = fully opaque)
    Callback = function(Value)
        _G.SquareColor = Value  -- Update the global variable with the new color
    end
})

BoxGroupBox:AddSlider('MySlider', {
    Text = 'Square Thickness',
    Default = 1.8,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        _G.SquareThickness = Value
    end
})

-- Rainbow ESP Toggle
BoxGroupBox:AddToggle('RainbowESP', { 
    Text = 'Rainbow ESP', 
    Default = _G.RainbowESP,
    Tooltip = 'Enable/Disable Rainbow effect for ESP',
    Callback = function(Value)
        _G.RainbowESP = Value  -- Store the state of the Rainbow ESP toggle
    end
})

-- Rainbow Speed Slider
BoxGroupBox:AddSlider('RainbowSpeedSlider', {
    Text = 'Rainbow Speed',
    Min = 5,  -- Minimum speed value (slower)
    Max = 15,    -- Maximum speed value (faster)
    Default = 12,  -- Default value
    Rounding = 1,  -- Number of decimal places to round the value to
    Tooltip = 'Adjust the speed of the rainbow effect',
    Callback = function(Value)
        _G.RainbowSpeed = Value  -- Update the global variable with the new speed value
    end
})

-- Function to Create ESP Squares for Players
local function CreateSquares()
    -- Loop through all players
    for _, v in next, game:GetService("Players"):GetPlayers() do
        if v ~= game.Players.LocalPlayer then  -- Skip local player
            if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                -- Create a new square to represent the player
                local Square = Drawing.new("Square")
                Square.Thickness = _G.SquareThickness
                Square.Transparency = _G.SquareTransparency
                Square.Color = _G.SquareColor  -- Initial color setup based on the global variable
                Square.Filled = _G.SquareFilled

                -- Connect to RenderStepped for updates
                game:GetService("RunService").RenderStepped:Connect(function()
                    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                        -- Get 3D world positions of humanoid root part and head
                        local Victim_HumanoidRootPart, OnScreen = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                        local Victim_Head = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(v.Character:FindFirstChild("Head").Position + _G.HeadOffset)
                        local Victim_Legs = game:GetService("Workspace").CurrentCamera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position - _G.LegsOffset)

                        -- Only show the square if player is on screen
                        if OnScreen and _G.EnableESP then
                            -- Set the size and position of the square
                            Square.Size = Vector2.new(2000 / Victim_HumanoidRootPart.Z, Victim_Head.Y - Victim_Legs.Y)
                            Square.Position = Vector2.new(Victim_HumanoidRootPart.X - Square.Size.X / 2, Victim_HumanoidRootPart.Y - Square.Size.Y / 2)

                            -- Apply Rainbow effect
                            if _G.RainbowESP then
                                local time = tick()
                                local r = math.sin(time * _G.RainbowSpeed) * 0.5 + 0.5
                                local g = math.sin(time * _G.RainbowSpeed + 2) * 0.5 + 0.5
                                local b = math.sin(time * _G.RainbowSpeed + 4) * 0.5 + 0.5
                                Square.Color = Color3.fromRGB(r * 255, g * 255, b * 255)
                            else
                                -- If Rainbow ESP is off, use the set color
                                Square.Color = _G.SquareColor
                            end

                            -- Update thickness and transparency dynamically
                            Square.Thickness = _G.SquareThickness
                            Square.Transparency = _G.SquareTransparency

                            -- Handle TeamCheck logic
                            if _G.TeamCheck then
                                if v.Team ~= game.Players.LocalPlayer.Team then
                                    Square.Visible = true
                                else
                                    Square.Visible = false
                                end
                            else
                                Square.Visible = true
                            end
                        else
                            Square.Visible = false
                        end
                    else
                        Square.Visible = false
                    end
                end)

                -- Clean up when the player leaves
                v.AncestryChanged:Connect(function(_, parent)
                    if not parent then
                        Square.Visible = false
                    end
                end)
            end
        end
    end
end

-- Reconnect when new players join
game:GetService("Players").PlayerAdded:Connect(function(v)
    -- Wait until the players character is loaded
    repeat wait() until v.Character and v.Character:FindFirstChild("HumanoidRootPart")
    
    -- Ensure the character exists and has a humanoid root part
    if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
        local Square = Drawing.new("Square")
        Square.Thickness = _G.SquareThickness
        Square.Transparency = _G.SquareTransparency
        Square.Color = _G.SquareColor  -- Initial color setup based on the global variable
        Square.Filled = _G.SquareFilled

        -- Connect RenderStepped to draw the box around the player
        game:GetService("RunService").RenderStepped:Connect(function()
            if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                local Camera = game:GetService("Workspace").CurrentCamera
                local Victim_HumanoidRootPart, OnScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                local Victim_Head = Camera:WorldToViewportPoint(v.Character:FindFirstChild("Head").Position + _G.HeadOffset)
                local Victim_Legs = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position - _G.LegsOffset)

                -- Only draw if the player is on screen and ESP is enabled
                if OnScreen and _G.EnableESP then
                    Square.Size = Vector2.new(2000 / Victim_HumanoidRootPart.Z, Victim_Head.Y - Victim_Legs.Y)
                    Square.Position = Vector2.new(Victim_HumanoidRootPart.X - Square.Size.X / 2, Victim_HumanoidRootPart.Y - Square.Size.Y / 2)

                    -- Apply Rainbow effect
                    if _G.RainbowESP then
                        local time = tick()
                        local r = math.sin(time * _G.RainbowSpeed) * 0.5 + 0.5
                        local g = math.sin(time * _G.RainbowSpeed + 2) * 0.5 + 0.5
                        local b = math.sin(time * _G.RainbowSpeed + 4) * 0.5 + 0.5
                        Square.Color = Color3.fromRGB(r * 255, g * 255, b * 255)
                    else
                        -- If Rainbow ESP is off, use the set color
                        Square.Color = _G.SquareColor
                    end

                    -- Apply Team Check
                    if _G.TeamCheck then
                        if v.Team ~= game.Players.LocalPlayer.Team then
                            Square.Visible = true
                        else
                            Square.Visible = false
                        end
                    else
                        Square.Visible = true
                    end
                else
                    Square.Visible = false
                end
            end
        end)
    end
end)

-- Initializing the squares when the script runs
CreateSquares()

local Tabs = {
    Main = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

local MiscGroupBox = Tabs.Main:AddLeftGroupbox('Misc')
local PlayerGroupBox = Tabs.Main:AddRightGroupbox('Local Player')

local function Noclip(enable)
    local plr = game.Players.LocalPlayer
    if plr and plr.Character then
        for i, v in pairs(plr.Character:GetDescendants()) do
            if v:IsA("BasePart") then
                v.CanCollide = not enable  -- Enable/Disable CanCollide based on the toggle
            end
        end
    end
end

-- Create the No Clip Toggle
MiscGroupBox:AddToggle('MyToggle', {
    Text = 'No Clip',
    Default = false,
    Tooltip = 'Enable/Disable No Clip (Disable collision with character)',
    
    Callback = function(Value)
        -- Call Noclip function with the toggle value
        Noclip(Value)  -- 'Value' will be true for enabling noclip, false for disabling
        print('[cb] MyToggle changed to:', Value)
    end
})

-- Define global variable for infinite jump state
_G.infinjump = false  -- Start with infinite jump disabled

-- Function to enable/disable infinite jump
local function ToggleInfiniteJump(value)
    _G.infinjump = value  -- Toggle the state of infinite jump

    -- If it's the first time running the script, set it up
    if _G.infinJumpStarted == nil then
        _G.infinJumpStarted = true  -- Ensures it only runs once to save resources
        
        -- Infinite jump functionality
        local plr = game:GetService('Players').LocalPlayer
        local m = plr:GetMouse()
        m.KeyDown:connect(function(k)
            if _G.infinjump then
                if k:byte() == 32 then
                    local humanoid = plr.Character:FindFirstChildOfClass('Humanoid')
                    if humanoid then
                        humanoid:ChangeState('Jumping')
                        wait()
                        humanoid:ChangeState('Seated')
                    end
                end
            end
        end)
    end
end

-- Toggle UI element for infinite jump
MiscGroupBox:AddToggle('InfiniteJumpToggle', {
    Text = 'Infinite Jump',
    Default = _G.infinjump,
    Tooltip = 'Enable/Disable Infinite Jump',
    
    Callback = function(Value)
        ToggleInfiniteJump(Value)  -- Toggle the infinite jump state based on the toggle value
    end
})


_G.HeadSize = 50
_G.Disabled = true
_G.HitboxColor = Color3.fromRGB(0, 0, 255)  -- Default to "Really Blue"
_G.HitboxTransparency = 0.7

MiscGroupBox:AddDivider()
MiscGroupBox:AddToggle('HitboxToggle', {
    Text = 'Hitbox',
    Default = _G.Disabled,
    Tooltip = 'use hitbox size slider and set to 0 to disable',

    Callback = function(Value)
        _G.Disabled = not Value  -- If toggle is off, disable hitbox modification
    end
})

-- Slider for changing the size of the hitbox
MiscGroupBox:AddSlider('HitboxSizeSlider', {
    Text = 'Hitbox Size',
    Default = _G.HeadSize,
    Min = 1,
    Max = 200,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        _G.HeadSize = Value  -- Adjust the size of the hitbox
    end
})

-- Color Picker for changing the hitbox color
MiscGroupBox:AddLabel('Hitbox Color'):AddColorPicker('HitboxColorPicker', {
    Default = _G.HitboxColor,  -- Default color is Really Blue
    Title = 'Hitbox Color',
    Transparency = _G.HitboxTransparency,  -- Initial transparency value

    Callback = function(Value)
        _G.HitboxColor = Value  -- Update the hitbox color
    end
})

-- Slider for changing the transparency of the hitbox
MiscGroupBox:AddSlider('HitboxTransparencySlider', {
    Text = 'Hitbox Transparency',
    Default = _G.HitboxTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,

    Callback = function(Value)
        _G.HitboxTransparency = Value  -- Adjust the transparency of the hitbox
    end
})

-- The function to handle the hitbox changes based on toggle
game:GetService('RunService').RenderStepped:connect(function()
    if not _G.Disabled then
        for i, v in next, game:GetService('Players'):GetPlayers() do
            if v.Name ~= game:GetService('Players').LocalPlayer.Name then
                pcall(function()
                    local hrp = v.Character and v.Character:FindFirstChild('HumanoidRootPart')
                    if hrp then
                        -- Modify hitbox properties
                        hrp.Size = Vector3.new(_G.HeadSize, _G.HeadSize, _G.HeadSize)
                        hrp.Transparency = _G.HitboxTransparency
                        hrp.BrickColor = BrickColor.new(_G.HitboxColor)
                        hrp.Material = "Neon"
                        hrp.CanCollide = false
                    end
                end)
            end
        end
    end
end)
MiscGroupBox:AddDivider()

local MyButton = MiscGroupBox:AddButton({
    Text = 'Fly',
    Func = function()
--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Quick Tip",
    Text = "Toggle hotkey : X", 
    Duration = 30 
    })
    wait(0.5)

local plr = game.Players.LocalPlayer
local mouse = plr:GetMouse()

localplayer = plr

if workspace:FindFirstChild("Core") then
    workspace.Core:Destroy()
end

local Core = Instance.new("Part")
Core.Name = "Core"
Core.Size = Vector3.new(0.05, 0.05, 0.05)

spawn(function()
    Core.Parent = workspace
    local Weld = Instance.new("Weld", Core)
    Weld.Part0 = Core
    Weld.Part1 = localplayer.Character.LowerTorso
    Weld.C0 = CFrame.new(0, 0, 0)
end)

workspace:WaitForChild("Core")

local torso = workspace.Core
flying = true
local speed=10
local keys={a=false,d=false,w=false,s=false}
local e1
local e2
local function start()
    local pos = Instance.new("BodyPosition",torso)
    local gyro = Instance.new("BodyGyro",torso)
    pos.Name="EPIXPOS"
    pos.maxForce = Vector3.new(math.huge, math.huge, math.huge)
    pos.position = torso.Position
    gyro.maxTorque = Vector3.new(9e9, 9e9, 9e9)
    gyro.cframe = torso.CFrame
    repeat
        wait()
        localplayer.Character.Humanoid.PlatformStand=true
        local new=gyro.cframe - gyro.cframe.p + pos.position
        if not keys.w and not keys.s and not keys.a and not keys.d then
            speed=5
        end
        if keys.w then
            new = new + workspace.CurrentCamera.CoordinateFrame.lookVector * speed
            speed=speed+0
        end
        if keys.s then
            new = new - workspace.CurrentCamera.CoordinateFrame.lookVector * speed
            speed=speed+0
        end
        if keys.d then
            new = new * CFrame.new(speed,0,0)
            speed=speed+0
        end
        if keys.a then
            new = new * CFrame.new(-speed,0,0)
            speed=speed+0
        end
        if speed>10 then
            speed=5
        end
        pos.position=new.p
        if keys.w then
            gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(-math.rad(speed*0),0,0)
        elseif keys.s then
            gyro.cframe = workspace.CurrentCamera.CoordinateFrame*CFrame.Angles(math.rad(speed*0),0,0)
        else
            gyro.cframe = workspace.CurrentCamera.CoordinateFrame
        end
    until flying == false
    if gyro then gyro:Destroy() end
    if pos then pos:Destroy() end
    flying=false
    localplayer.Character.Humanoid.PlatformStand=false
    speed=10
end
e1=mouse.KeyDown:connect(function(key)
    if not torso or not torso.Parent then flying=false e1:disconnect() e2:disconnect() return end
    if key=="w" then
        keys.w=true
    elseif key=="s" then
        keys.s=true
    elseif key=="a" then
        keys.a=true
    elseif key=="d" then
        keys.d=true
    elseif key=="x" then
        if flying==true then
            flying=false
        else
            flying=true
            start()
        end
    end
end)
e2=mouse.KeyUp:connect(function(key)
    if key=="w" then
        keys.w=false
    elseif key=="s" then
        keys.s=false
    elseif key=="a" then
        keys.a=false
    elseif key=="d" then
        keys.d=false
    end
end)
start()
    end,
    DoubleClick = false,
    Tooltip = 'Press X to toggle'
})

-- Speed Changer
PlayerGroupBox:AddSlider('SpeedSlider', {
    Text = 'Speed Changer',
    Default = 16,
    Min = 16,
    Max = 2000,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Ensure the Humanoid object is found and set the WalkSpeed to the new value
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = Value
        end
    end
})

-- Jump Changer
PlayerGroupBox:AddSlider('JumpSlider', {
    Text = 'Jump Changer',
    Default = 50,
    Min = 50,
    Max = 750,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Ensure the Humanoid object is found and set the JumpPower to the new value
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.JumpPower = Value
        end
    end
})

-- Max Health (Visual) Changer
PlayerGroupBox:AddSlider('HealthSlider', {
    Text = 'Max Health [VISUAL]',
    Default = 100,
    Min = 1,
    Max = 1000,
    Rounding = 1,
    Compact = false,

    Callback = function(Value)
        -- Ensure the Humanoid object is found and set the MaxHealth to the new value
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.MaxHealth = Value
        end
    end
})

-- Gravity Changer
PlayerGroupBox:AddSlider('GravitySlider', {
    Text = 'Gravity Changer', 
    Default = 196.2,  -- Default gravity value
    Min = 0,         -- Minimum gravity value
    Max = 10,         -- Maximum gravity value
    Rounding = 1,     -- Number of decimal places
    Compact = false,

    Callback = function(Value)
        -- Change the gravity of the workspace based on the slider value
        game.Workspace.Gravity = Value * 196.2  -- The default gravity is 196.2, so adjust accordingly
    end
})

local MyButton = PlayerGroupBox:AddButton({
    Text = 'set everything back to default',
    Func = function()
        game.Workspace.Gravity = 196.2
        wait(0.1)
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.MaxHealth = 100
            wait(0.1)
            local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.JumpPower = 50
                wait(0.1)
                local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = 16
                end
            end
        end
    end,
    DoubleClick = false,
    Tooltip = 'will not reset sliders, only your stats'
})

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

-- I set NoUI so it does not show up in the keybinds menu
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind -- Allows you to have a custom keybind for the menu

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()


SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('MyScriptHub')
SaveManager:SetFolder('MyScriptHub/specific-game')

-- Builds our config menu on the right side of our tab
SaveManager:BuildConfigSection(Tabs['UI Settings'])


ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
end)
else
       setclipboard(KeyGuardLibrary.getLink())

    game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Notification",
    Text = "If you dont have a key, the key system has been copied to clipboard", 
    Duration = 30 
    })
end
